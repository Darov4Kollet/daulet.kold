---
{"dg-publish":true,"permalink":"/atlas/zametki/dokumentacziya/0-java-dlya-nachinayushhih-level-2/10-potoki-vvoda-vyvoda/","tags":["Java"],"noteIcon":"","created":"2023-12-12T23:23:52.171+05:00","updated":"2025-04-07T02:08:56.455+05:00"}
---


## 001 Класс File

Создали новый класс FileRunner в пакете lesson22:

Есть два основных процесса как мы можем передавать информацию, 1) Output stream - например у нас есть приложение (aplication) передавать информацию из нашего приложение в другое приложение либо в файл в нашем жестком диске. По файл мы понимаем любой объект в нашем жестком диске. Может это быть видео, картинка либо просто текстовая информация, все что угодно.  
2)Input Stream - Так же есть наоборот у нас есть наше приложение и мы хотим получить из какого-то источника информаций в наше приложение.

Создаем объект file типа File, в параметрах конструктора передаем File(“resources/test.txt”),

У класса File есть метод который называется file.exists(), то есть существует ли этот файл или нет // false

==file.isFile() – это файл==

==file.isDirectory() – либо это диерктория==

Для того чтобы создать файл мы можем воспользоваться двумя вариантами. Первое либо записать туда какую-то информацию, по умолчанию если мы записываем информацию например в наш файл test.txt, а если мы хотим записывать какой-то текст в наш файл то это output stream. А если по умолчанию если его там не будет, файла на жестком диске, то он автоматически создаться, но мы сами можем вручную создать этот файл вызвав у нашего объекта типа File метод createNewFile(). Тут у нас может быть ошибка, а именно исключение IOException.

Если файл представляет из себя директорию а не файл, то мы можем вызвать команду ==mkdir()== “make directory” чтобы создать его, ну или mkdirs() чтобы создать несколько директорий.

Создаем объект dir типа `File`, и она будет в папке `resources/test/dir File(“resources/test/dir”)`, в данным случае у нас нет не test не dir. Для того чтобы создать все директорий до нашей папочки dir, мы делаем следующим образом, dir.mkdirs().

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.1/src/com/dmdev/oop/lesson22)

## 002 Класс InputStream

`InputStream` – помогает нам получат какую-либо информацию из вне, из любого источника в наше приложения.

InputStream – это базовый класс для всех наших стримов, и он является абстрактным, то есть мы не можем создать объект этого класса. В свою очередь он реализует интерфейс `Closeable`. Этот интерфейс довольно простой, он содержит всего лишь один простой метод close(), и он нужен нам для того чтобы закрывать потоки.

Создали класс `InputStreamRunner`, в тестовом файле есть текст, мы должны считать его из файла и вывести на консоль. Создали метод main. Создали объект inputStream типа `FileInputStream` который на вход принимает какой-то файл и в inputStream мы должны передать этот файл, так мы создаем его. Создаем объект file типа File, на нем указываем путь к нашему файлу который лежит в `resources/test.txt`.

Есть маленький нюанс по поводу этого слеша «/». Дело в том что разделение каталогов либо файлов от каталогов отличается от Unix систем и например от Windows, следовательно это не совсем безопасно использовать если ваша программа работает к примеру на Windows. Таким образом мы должны воспользоваться константой. Это константа есть у нашего класса File и она называется File.separator() Для того чтобы правильно написать разделение resources/test.txt нам нужно использовать String.join и говорить что у нас есть разделитель separator и далее мы просто через запитую перечисляем все директорий и файлы которые мы хотим чтобы они были разделены через наш separator. File file = new File(String.join(File.separator, “resources”, “test.txt”));

Но так как это приходилось очень часто делать, следовательно создался новый класс в Java 1.7. Это класс называется Path. Мы можем им воспользоваться для того чтобы создать файл. Все что необходимо сделать это вызвать статический метод of() и передать туда String, это как раз путь к нашему файлу, где мы перечисляем через запитую наши директорий и файлы. Таким образом мы получаем объект Path, более того мы можем при необходимости вызвать метод toFile() для того чтобы преобразовать наш Path в File.` File file = Path.of(“resources”, “test.txt).toFile();`

Далее после того как мы отработали с нашим inputStream, мы объязаны его закрыть, то есть вызвать метод close(). Раньше до Java 1.7 нам приходилось блок finally и там закрывать наш inputStream, что было очень неудобно. Таким образом try this resources очень упрощает нам работу с закрытиями нашего потока, все что нам необходимо сделать это просто обернуть его в try-with-resources. Это выглядит как обычный блок try, просто перед блоком try между отр. закр. скобочками мы в круглых скобочках можем перечислить все потоки которые мы хотим закрыть после работы с этим try, просто перечисляя их просто через точку с запитой «;»

У inputStream есть метод readAllBytes() который считывает нам все байты. И чтобы вставить все байты в виде строки, мы можем просто в объект типа String в конструктор передать его. String stringValue = new String(bytes); И просто можем вывести его на консоль.

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.2/src/com/dmdev/oop/lesson22)
## 003 Класс Reader

При работе с inputStream мы можем считывать любой файл будь это картинка, видео, аудио либо обычный текстовый файл. То есть он предоставляет нам более общий интерфейс для работы с любым потоком. Но очень часто мы работаем с текстовыми файлами и хотели бы считывать данные более удобные для нас форме, то есть построчно к примеру. Таким образом у нас есть отдельная иерархия классов именно для считывания информации, данных из вне в наше приложение, мы используем базовый класс Reader.

`Reader` – предназначен для работы именно с текстовой информацией, а InputStream – с любым потоком байтов.

Создаем класс ReaderRunner и функцию main, создаем объект file типа File, с помощью Path.of(“resources”, “text.txt”) пишем путь к нашему файлу. Потом преобразуем его в файл с помощью .toFile(). Потом создаем new FileReader() который является наследником от InputStreamReader который принимает любой InputStream который мы захотим, но в данном случае мы теперь имеем возможность создавать этот FileReader просто передав туда необходимый файл. Далее передаем туда наш файл. Как и любой другой InputStream, FileReader необходимо так же закрывать после использование, и он тоже реализует интерфейс `AutoCloseble`, слеователно оборачиваем в try-with-resources. Потом подбрасываем исключении. И уже когда мы используем fileReader для того чтобы считать следующий символ а не байт, мы так же воспользуемся методом read(). Но мы здесь уже можем воспользоваться декорируемым объектом из иерархий Reader, точно так же мы могли бы воспользоваться декорируемым объектом BufferedReader. Мы пишем new `BufferedReader()` который на вход любой Reader. Он предоставляет нам новые методы более удобные для работы с нашим fileReader. Теперь у нас есть функционал сразу же качать все наши строки в виде `Stream<String>`, далее мы можем считать строку вызвать метод .readLine(). В readLine мы будем его скачивать до тех пор пока мы не увидим null, то есть до тех пор пока метод readLine не вернёт null мы можем его считывать в нашем цикле.

Нам удобнее будет скачать его в виде Stream стрима(потока), следовательно просто вызываем у него метод lines() и сколлектим их в одну строку с помощью метода .collect() и воспользовавшись Collectors.joining(), и здесь мы просто каждую строку разделим специальным символом `/n` который означает переход на новую строку. В итоге мы получаем нашу общую строку, то есть со всем текстом из нашего файла и просто выводим его на консоль.

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.3/src/com/dmdev/oop/lesson22)

## 004 Класс OutputStream

Мы узнаем как записывать данный файл, не только извлекать из него.
Для того чтобы получить какую-то информацию из любого источника нам необходимо использовать ==input stream==. Если же мы использовали этот же источник для получение текста, то мы могли бы так же использовать reader.
НО если же мы хотим наоборот передавать из нашего приложение какую-то информацию в другие источники, в файл, в другое приложение либо передача информации через интернет, то мы должны использовать ==output stream==.
Самый базовый класс для наших output stream-ов это - ==OutputStream==.
Он похож на ==InputStream==, то есть он тоже является абстрактным и он также наследует интерфейс ==Closeable==, то есть мы так же как и ==InputStream== должны его закрывать после того как мы передали всю необходимую информацию из нашего приложение в какое-либо источник.

>[!info]- Функционалы OutputStream
`OutputStream()` -  конструктор без параметров
`close()` - метод который закрывает поток
`flush()` - метод который при записи в файл использовать какое-либо буфер.
`write(byte[])` - метод для записи информации
`write(byte[], int, int)` - метод для записи информации
`write(int)` - метод для записи информации

>[!info]- Наследники Output Stream
`ByteArrayOutputStream(java.io)` - то есть мы хотим работать с массивом `byte[]`, в нем есть метод `toByteArray(): byte[]` который сразу нам возвращает  весь массив `byte[]` который мы хотим передать какому-то источнику.
`ObjectOutputStream(java.io)` - когда мы хотим передавать источнику информацию ввиде объектов нашей Java-ы, то есть обычные массивы, ==boolean==, ==byte==, ==char==. Мы будем его использовать для серилезации и десерилезации.
`FileOutputStream(java.io)` - так же как и ==FileInputStream== мы будем его использовать для работы с файлами, то есть если мы захотим записать какую-то информацию в файл, то самый оптимальный пример это ==FileOutputStream== который у себя в качестве конструкторов имеет File либо String.
`FilterOutputStream(java.io)` - содержит в себе подклассы для модификации поведением потоков, ну например ==BufferedOutputStream== который добавляет нам возможность буферизирование нашего потока.

Так как мы будем работать с файлом мы создадим FileOutputStream(), который на вход будет принимать наш file.

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.4/src/com/dmdev/oop/lesson22)

## 005 Класс Writer

У нас есть специальная иерархия классов которые упрощают нам работу с текстом и позволяет нам записывать сразу же массив char либо массив строк в какой-либо поток и он называется ==Writer==

Writer также реализован от интерфейсов ==Closeable==, ==Flushable==  и ==Appendable==
У него так же есть методы `write()`, но на этот раз они работают не с byte или массивом byte[] а char либо String строками. Так же у него есть метод `append()` которые позволяет добавлять нам в конец файла какие либо символы.

>[!info]- Иерархия классов Writer
`PrintWriter` - в нем есть много удобных способов создание его, во первых мы можем его создать на основе File, String, либо на основе любого другого OutputStream. Так же мы можем создать кодировку тех символов которые будут ему передаваться. Далее у него есть метод newLine(), с помощью которого нам не нужно теперь вручную использовать line сепараторы. И куча методов print() которые позволяют нам записывать в выходной поток любой тип которые мы знаем, то есть ==boolean==, ==char==, ==double==, ==float==, ==int==, ==long==, ==Object==, ==String==
`BufferedWriter` - он предоставляет нам возможность буферизовать поток что ускоряет в данном случае запись из нашего приложения. У него тоже есть метод `newLine()` - для перевода на новую строку и как у любого другого метод write() - для записи сразу же целой строки.
`OutputStreamWriter` - позволяет нам просто работать с нашим файлом, например FileWriter

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.5/src/com/dmdev/oop/lesson22)
## 006 Класс Files

Очень часто нам приходится вкладывать один поток вывода в другой, и такие цепочки могут быть ещё сложнее, если мы к примеру будем использовать не ==FileWriter== а какой-нибудь ==OutputStreamWriter== который в свою очередь будет принимать уже OutputStream а не файл, следовательно для того чтобы упростить такой механизм были добавлены начиная с Java 1.7 соответствующие классы и в последующим они обогащались новыми методами и естественно это были утилитные классы которые можем использовать для своих нужд чтобы упростить работу с реальными операциями ввода-вывода и работа с файлами.

`Files` - это обычный утилитный класс, он помещен в final и мы не можем наследоваться от него и он имеет private конструктор. У него нет методов которые работают с классом File, здесь везде Path

>[!info] Функционалы Files
>`copy()`- перегруженный метод, очень часто нам необходимо содержимое одного файла скопировать в другой файл либо выходной поток.
>`createDirectories()` - если нам необходимо создать директории либо одну директорию то мы просто передаем туда Path. То есть нам не нужно создавать объект класса File и у него вызывать метод mkdir. Просто можем воспользоваться утилитными методами класса Files. Тоже самое с методами `createFile()`.
>`delete()` - удалить файл
>`walk()` - для итерирование по всему дереву каталогов и найти все что нам необходимо.

`Scanner` - класс для работы с потоками ввода

>[!info] [Github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-22.6/src/com/dmdev/oop/lesson22)