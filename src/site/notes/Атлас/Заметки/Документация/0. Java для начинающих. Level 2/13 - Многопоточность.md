---
{"dg-publish":true,"permalink":"/atlas/zametki/dokumentacziya/0-java-dlya-nachinayushhih-level-2/13-mnogopotochnost/","tags":["Java"],"noteIcon":"","created":"2023-12-12T23:25:27.511+05:00"}
---

## 001 Введение в многопоточность. Класс Thread

Есть 2 способа создать несколько потоков.
	1. Это создание экземпляров унаследовавшись от нашего класса **==Thread==**
	2. Реализовать интерфейс ==**Runnable**==

**Многопоточность** - например множество людей могут воспользоваться каким ни-будь сайтом для покупки каких  ни-будь вещей. 10 а то и 100 пользователей могут одновременно делать запрос к нашему приложению и как-то получать ответ на этот запрос. Следовательно в Java из коробки поддерживается возможность обработки множества запросов одновременно. Это и есть многопоточность. То есть каждый пользователь это по сути отдельный поток который обрабатывается нашим Java приложением.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.1/src/com/dmdev/oop/lesson25)
## 002 Интерфейс Runnable

Интерфейс Runnable -  этот интерфейс позволяет вам выполнять несколько операций одновременно. Интерфейс Runnable позволяет вам создавать дополнительные потоки, в которых можно выполнять код параллельно с главным потоком.

**Как использовать интерфейс Runnable?**

Чтобы использовать интерфейс Runnable, вы должны следовать этим шагам:

1. Создать класс, который реализует интерфейс Runnable.
2. Переопределить метод `run()` в созданном классе. Этот метод будет содержать код, который вы хотите выполнить в отдельном потоке.
3. Создать объект класса, который реализует Runnable.
4. Создать объект класса `Thread` и передать в конструктор объект Runnable.
5. Вызвать метод `start()` на объекте Thread для запуска выполнения кода в отдельном потоке.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.2/src/com/dmdev/oop/lesson25)
## 003 Состояния потоков

У каждого потока есть определенная состояние в определенный момент времени. Обращаясь к ссылкам наших потоков мы можем вызвать метод `.getState()` - именно это и есть текущее состояние нашего потока.

>[!info] Виды состоянии потоков
>`NEW` - как только мы создали наш поток он имеет состояние new.
>`RUNNABLE` - как только мы запустили его то есть сделали ==Thread.start== то он будет runnable.
>`BLOCKED` - поток блокирован каким-то другим потоком, то есть он не может свершить какое-то действие до тех пор пока это действие не завершит другой поток.
>`WAITING` - поток ждёт выполнение чего либо. Есть несколько способов получить это состояние и одно из них это ==Thread.join==. То есть до тех пор пока тот поток у которого был вызван  этот метод не закончит свое выполнение, наш main в состоянии waiting.
>`TIMED_WAITING` - когда мы передаём еще определенное количество секунд сколько мы можем ждать.
>`TERMINATED` - то есть когда наш поток закончил свое выполнение у него состояние terminated. То есть после того как он закончит свое выполнение, еще раз его запустить не получится. 

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.3/src/com/dmdev/oop/lesson25)

## 004 Атомарность операций

Атомарная операция - это только операция которая выполняется в одной действий для нашего процессора.

Давай представим, что у нас есть переменная `x`, и два потока хотят увеличить ее значение на 1. Если операция увеличения не является атомарной, то может произойти так, что оба потока начнут увеличивать значение `x` одновременно, и мы можем потерять одно из увеличений. Например, если `x` было 5, оба потока могут прочитать это значение, увеличить его на 1 и записать обратно, но в результате значение `x` может оказаться 6 вместо 7.

Чтобы избежать таких ситуаций, Java предоставляет атомарные операции, такие как `AtomicInteger` или `synchronized` блоки. В них гарантируется, что операции выполняются целиком и никакой другой поток не может вмешаться в процесс, пока операция не завершится.

Таким образом, атомарность операций в Java важна для предотвращения конфликтов и непредсказуемого поведения при работе с разделяемыми данными в многозадачных приложениях.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.4/src/com/dmdev/oop/lesson25/counter)

## 005 Ключевое слово synchronized

Ключевое слово ==synchronized== можно использовать двумя разными способами.  
==Первый== - это synchronized на уровне метода, то есть мы помечаем наш метод synchronized, таким образом говоря что в один и тот же момент времени только один поток у одного и того же объекта может вызвать это метод. 
==Второй== - это использование syncjronized на уровне блока, то есть мы используем слово synchronized и в круглых скобочках указываем объект который мы хотим синхронизировать.

**Синхронизация:** Ключевое слово `synchronized` решает проблемы с параллельным доступом к ресурсам. Когда вы помечаете блок кода или метод ключевым словом `synchronized`, это означает, что только один поток может выполнить этот блок кода или метод в данный момент времени.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.5/src/com/dmdev/oop/lesson25/counter)

## 006 Синхронизация коллекций

У нас есть утилитный класс Collections где у нас есть множество методов для созданий обёрток вокруг наших коллекции и эти обёртки будут потокобезопасными. Например `synchronizedList()`, дело в том что `synchronizedList()` возвращает всего-лишь обёртку вокруг нашего листа. В данном случае у нас будет ==RandomAccess== потому что это ArrayList. 

В ==SynchronizedRandomAccessList== мы используем list как поле, для наших ==synchronizedList==, и все его методы нашего листа просто переопределены, и каждый из них использует ==synchronized== блок. Только в этом случае они используют не сам объект лист для захвата монитора а специальный объект ==mutex==. Дело в том что очень часто выделают отдельный объект для захвата монитора а не используют коллекцию в нашем случае. Это все для того чтобы разделять обязанности в нашем классе, потому что захват монитора это уже считается другой обязанностью, следовательно 
используется другой объект как поле в нашем объекте который мы хотим захватить монитор. В данном случае ==**mutex**== это ==this==, то есть разницы никакой нету. 
>==Любой из самых распространенных коллекции можно синхронизировать==

На самом деле так не очень хорошо делать, дело в том что сам захват монитора это операция которая так же занимает какое-то процессорное время, естественно это не критична но тем не менее, захват монитора является трудоёмкой операцией. Следовательно такую конструкцию, то есть ==Collections.synchronizedList== либо синхронизация любой другой коллекции, все это используется только в крайних случаях.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.6/src/com/dmdev/oop/lesson25/list)

## 007 Ключевое слово volatile

У нас могут быть несколько ядер в одном процессоре которые выполняют наш код, следовательно у нас может быть следующая ситуация. То есть у нас есть два ядра, по сути каждый из них выполняет каждый из потоков. Поля наших классов храниться в Heap-e, по сути это обычное оперативное память и здесь ==flag=false==.  И когда у нас происходит считывание кого-го либо поля в потоке велик шанс того что наш процессор использует свой кэш для хранение этой информации. То есть он первый раз считает информацию из оперативной памяти и может положит если захочет в свой кэш процессор. То есть сделать ==flag=false==, для того чтобы не обращаться в оперативную память. Далее мы в нашем потоке thread2 меняем значение flag=true, что может произойти? Первое, это то что ядро два может не сразу же обновить нашу оперативную память из своего кэша. То есть он обновил свой кэш но не передал эти данные в наш RAM. Либо, когда он всё таки передал изменившейся данные сразу же, допустим, то поток1 который выполняет наше первое ядро, может не сразу же видеть эти изменение и всё еще использовать закэшированное значение из кэша процессора. Следовательно для того чтобы не допускать таких проблем есть ключевое слово ==volatile==

Volatile - оно говорит что мы не должны использовать никаких оптимизации. И одна из оптимизации это не использовать кэша процессора. То есть каждый раз когда мы хотим получить значение нашего поля, считать его либо изменить, мы всегда должны получать эту информацию и сохранять его из оперативной памяти.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.7/src/com/dmdev/oop/lesson25/vol)

## 008 Потокобезопасный объект

Если мы используем наш объект только как локальные переменные не передавая ей какие-либо другие потоки, следовательно она автоматический становится безопасной в многопоточности. Если же у нас все таки не получается это сделать, нам необходимо передать этот объект в другой поток, следовательно у нас есть 4 варианта как сделать наш объект потокобезопасной.
	1 вариант - это не создавать полей, то есть по сути это будет наш утилитный класс с множеством методов.
	2 вариант - это сделать наш класс immutable, то есть на попытки изменить наш объект будет всегда возвращаться другой объект, новый, одного и того же типа. Например класс String.
	3 вариант - мы можем сделать просто ==read only== поля, то есть мы не предоставляем методов которые изменяет состояние нашего объекта, а методы на чтение мы возвращаем таким образом чтобы нельзя было из вне изменить состояние через ссылку.
	4 вариант - мы должны синхронизировать каждый метод либо использовать synchonized блок в каждом методе для того чтобы в один и то тот же момент времени у нас мог только один поток изменять наш объект.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.8/src/com/dmdev/oop/lesson25)

## 009 Методы wait, notify, notifyAll. Часть 1

Эти методы используются для синхронизации между потоками, чтобы они могли безопасно обмениваться информацией и избегать конфликтов при доступе к общим ресурсам.

1. **`wait`**: Этот метод вызывается внутри синхронизированного блока кода и заставляет текущий поток ждать, пока другой поток не вызовет метод `notify` или `notifyAll` для объекта, над которым был вызван `wait`. Поток, вызвавший `wait`, освобождает монитор объекта и переходит в режим ожидания.
    
2. **`notify`**: Этот метод также вызывается внутри синхронизированного блока кода и будит один из потоков, ожидающих уведомления (`wait`). Если есть несколько потоков, ожидающих, то не определено, какой именно поток будет разбужен. Выбор зависит от реализации виртуальной машины.
    
3. **`notifyAll`**: Этот метод, также вызывается внутри синхронизированного блока кода, будит все потоки, ожидающие уведомления (`wait`). Этот метод гарантирует, что все потоки получат уведомление, и каждый из них будет пытаться взять монитор объекта.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.8/src/com/dmdev/oop/lesson25)
## 010 Методы wait, notify, notifyAll. Часть 2

Метод `wait()` нужен для того чтобы поток который вызвал его на объекте ждал определенное время либо не определенное время, всё зависит от того какой из перегруженных методов `wait()` мы вызвали. То есть  с количеством времени мили-секунд или даже нано-секунд либо без времени. Если с определенным количеством времени мы будем ждать как минимум это время, а как максимум до тех пор пока мы не сможем вновь захватить монитор того объекта на котором мы вызвали метод `wait()`. Более того метод `wait()` отпускает монитор как только мы вызвали метод `wait()`, поток освободил монитор объекта у которого вызван был метод `wait()` и другие потоки могут опять захватить монитор у наших объектов.

Ни `wait()` ни `notify()` ни `notifyAll()` нельзя вызывать у объектов монитор которых не захватили. В случае же с `notify()`, `notifyAll()` - эти методы нужны только для того чтобы уведомить другие потоки которые вызвали на этом же самом объекте метод `wait()` что они могут продолжать своё выполнение как только поток который вызвал `notify()`либо `notifyAll()` отпустит монитор объекта.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.8/src/com/dmdev/oop/lesson25)

## 011 Deadlock

Deadlock или дедлок в Java или взаимная блокировка — это ошибка, которая происходит когда нити имеют циклическую зависимость от пары синхронизированных объектов. Представьте, что одна нить входит в монитор объекта `x`, а другая — объекта `y`. Если нить в объекте `x` пытается вызвать любой синхронизированный метод объекта `y`, а объект `y` в то же самое время пытается вызвать любой синхронизированный метод объекта `x`, то нити застрянут в процессе ожидания. Это ситуация в многозадачных программах, когда два или более потока (или процесса) не могут продолжить выполнение из-за того, что каждый из них удерживает ресурсы, необходимые для другого.

[https://github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.11/src/com/dmdev/oop/lesson25/account)
## 012 Многопоточность. Практика

[task](https://github.com/dmdev2020/java-level2-starter/tree/lesson-25.12/src/com/dmdev/oop/lesson25/task)