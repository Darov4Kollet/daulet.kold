---
{"dg-publish":true,"permalink":"/atlas/zametki/dokumentacziya/0-java-dlya-nachinayushhih-level-2/14-paket-java-util-concurrent/","tags":["Java"],"noteIcon":"","created":"2023-12-15T13:37:03.675+05:00","updated":"2025-04-07T02:09:16.011+05:00"}
---

[Справочник по синхронизаторам java.util.concurrent.\* / Хабр](https://habr.com/ru/articles/277669/)

## 001 Пакет java.util.concurrent. Введение

Пакет javav.util.concurrent предоставляет собой классы и интерфейсы которые облегчают работу с параллельным программированием и сопровождение многопоточных приложений.

Вот некоторые из основных классов и интерфейсов пакета java.util.concurrent:

- **ExecutorService** - интерфейс, который предоставляет методы для запуска и управления потоками.
- **ThreadPoolExecutor** - класс, который реализует интерфейс ExecutorService. Он предоставляет удобные методы для создания и управления пулом потоков.
- **Callable** - интерфейс, который представляет задачу, которая может возвращать результат.
- **Future** - интерфейс, который представляет результат выполнения задачи.
- **Semaphore** - класс, который используется для управления доступом к ограниченному ресурсу.
- **Lock** - класс, который используется для синхронизации доступа к разделяемому ресурсу.
- **Condition** - класс, который используется для синхронизации доступа к разделяемому ресурсу в ожидании определенного события.

Атомики и локи - это два основных способа синхронизации доступа к данным в многопоточных приложениях.

**Атомики** - это специальные переменные, которые гарантируют, что операции над ними выполняются atomically, то есть как единое целое. Это означает, что если один поток выполняет операцию над атомической переменной, то другие потоки не смогут увидеть результаты этой операции до тех пор, пока поток не завершит ее.

**Локи** - это механизм, который позволяет одному потоку захватить доступ к ресурсу и заблокировать его для других потоков. Это гарантирует, что только один поток будет иметь доступ к ресурсу в любой момент времени.

## 002 Atomic

Атомики в Java.util.concurrent - это классы, которые предоставляют атомарные операции над переменными. Атомарная операция - это операция, которая выполняется как единое целое, без возможности вмешательства других потоков.

Объект Unsafe - это специальный класс, который предоставляет доступ к низкоуровневым операциям над памятью. Объект Unsafe может использоваться для реализации различных задач, которые не могут быть выполнены с помощью обычных средств Java.

![Pasted image 20231216002853.png](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/Pasted%20image%2020231216002853.png)
Этот код является методом класса `Unsafe`, который используется для атомарного увеличения значения целочисленной переменной. Метод принимает три аргумента:

- `o` - объект, содержащий переменную, значение которой необходимо увеличить.
- `offset` - смещение переменной в объекте.
- `delta` - значение, на которое необходимо увеличить переменную.

Метод `getAndAddInt()` работает следующим образом:

1. Он сначала получает текущее значение переменной с помощью метода `getIntVolatile()`.
2. Затем он пытается установить новое значение переменной с помощью метода `weakCompareAndSetInt()`. Если установка прошла успешно, то метод возвращает текущее значение переменной. Если установка не удалась, то метод повторяет попытку.

Метод `weakCompareAndSetInt()` работает следующим образом:

1. Сначала метод читает текущее значение переменной из памяти.
2. Затем метод сравнивает текущее значение переменной с ожидаемым значением.
3. Если текущее значение переменной совпадает с ожидаемым значением, то метод устанавливает новое значение.
4. Если текущее значение переменной не совпадает с ожидаемым значением, то метод возвращает `false`.

Метод `getIntVolatile()` выполняет атомарную операцию получения значения переменной. Метод `weakCompareAndSetInt()` выполняет атомарную операцию сравнения и установки значения переменной.

[atomic](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.2/src/com/dmdev/oop/lesson26/atomic)

## 003 Lock

В Java интерфейс `Lock` предоставляет более гибкий и мощный механизм управления блокировками (locks) по сравнению с традиционным использованием `synchronized` блоков. `Lock` находится в пакете `java.util.concurrent` и предоставляет более продвинутые возможности для управления блокировками в многопоточных приложениях.

Локи используется для обеспечения безопасности выполнения потоков в многозадачной среде, где несколько потоков могут пытаться одновременно обратиться к общим данным. Простыми словами, локи предназначены для того, чтобы предотвращать конфликты доступа к ресурсам между потоками. Когда один поток владеет локом, другие потоки должны ждать, пока этот лок не будет освобожден.

Принципиальные методы интерфейса `Lock`:

1. `void lock()`: Захватывает блокировку. Если блокировка уже занята другим потоком, текущий поток блокируется до тех пор, пока блокировка не станет доступной.
    
2. `void unlock()`: Освобождает ранее захваченную блокировку.
    
3. `boolean tryLock()`: Попытка захвата блокировки. Если блокировка доступна, метод ее захватывает и возвращает `true`. Если блокировка занята другим потоком, метод возвращает `false` без блокировки текущего потока.
    
4. `boolean tryLock(long time, TimeUnit unit) throws InterruptedException`: Попытка захвата блокировки с ожиданием. Пытается захватить блокировку в течение указанного времени. Если блокировка становится доступной в течение заданного времени, метод возвращает `true`. В противном случае возвращается `false`.

Интерфейс `Lock` имеет несколько реализаций в стандартной библиотеке Java. Одна из них - `ReentrantLock`. Этот класс реализует интерфейс `Lock` и предоставляет функциональность повторного входа в блокировку, что означает, что один и тот же поток может многократно захватывать и освобождать блокировку.

`ReentrantLock` используется для создания блокировки. После входа в критическую секцию с помощью `lock()`, блокировка должна быть освобождена с помощью `unlock()` в блоке `finally`. Это гарантирует, что блокировка всегда будет освобождена, даже если в критической секции произойдет исключение.

[account](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.3/src/com/dmdev/oop/lesson25/account)

## 004 ThreadPool. Future. Callable. Часть 1

**ThreadPool** - это множество объектов типов Thread, которые мы можем использовать для выполнение задач. Это набор (или "пул") потоков, которые готовы выполнить задачи. Вместо того чтобы создавать новый поток каждый раз, когда нужно выполнить задачу, можно использовать существующие потоки из пула.

ThreadPool помогает эффективно управлять потоками. Создание и уничтожение потоков занимает какое-то время, то есть это трудозатратное операция, и ThreadPool позволяет переиспользовать потоки для выполнения различных задач, сэкономив ресурсы.

ThreadPool помогает избежать избыточного использования ресурсов, таких как память и процессорное время. Он также обеспечивает контроль над количеством потоков, что помогает предотвратить перегрузку системы.

Для создание Пулов потоков у нас есть утилитный класс которая называется Executors(экзекютеры), на подобие Collections. Коллекции массивов Arrays, Objects и т.д.

`Executors` - это вспомогательный класс в Java, который помогает управлять потоками, особенно при создании и использовании пулов потоков (ThreadPool).

У нас есть 5 разных вариантов создание пулов потоков: (первые 3 из них будут часто встречаемыми)
1. Executors.**newSingleThreadExecutor**()**;** - создает ThreadPool который состоит из одного единственного потока.
2. Executors.**newFixedThreadPool**(*nThreads:* 5)**;** - создает столько потоков сколько мы передали, в данном случае у нас будет пул потоков из 5 потоков.
3. Executors.**newCachedThreadPool**()**;** - он безграничный, то есть сколько задач одновременно мы отправим, столько потоков будет создано. Он самостоятельно управляет сколько потоков использовать в каждый момент времени. Когда вы отправляете задачу на выполнение в пул, если есть свободный поток, то он сразу берет и выполняет вашу задачу. Если все потоки заняты, пул может создать новый поток, если это необходимо. Если поток не используется в течение некоторого времени, он может быть завершен.
4. Executors.**newScheduledThreadPool**(*corePoolSize:* 3)**;** -  создает пул потоков, который может выполнять задачи по расписанию, например, через определенные промежутки времени или в определенное время суток. Этот тип пула потоков выполняет задачи с определенной периодичностью, например, каждую минуту или каждый час.
5. Executors.**newWorkStealingPool**()**;** - создает пул потоков, который использует алгоритм "work stealing". Этот алгоритм позволяет потокам автоматически "украсть" задачи у других потоков, если у них нет своих задач для выполнения. Этот тип пула потоков особенно полезен в ситуациях, где задачи имеют различную интенсивность выполнения, и эффективное распределение нагрузки между потоками может улучшить производительность. Пул потоков создается, и каждый поток в нем имеет свой собственный стек задач. Когда поток заканчивает выполнение своих задач, он может "украсть" задачу из стека другого потока, который занят.

[pool](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.4/src/com/dmdev/oop/lesson26/pool)

## 005 ThreadPool. Future. Callable. Часть 2

***Какие у ThreadPool есть методы?***
`submit(Runnable task)` - Этот метод используется для представления задач, которые выполняют какую-то работу, но не возвращают результат.
`submit(Callable<T> task)` - Этот метод используется для представления задач, которые возвращают результат (обобщенный тип `T`).
`execute(Runnable command)` - позволяет передать задачу в пул потоков для асинхронного выполнения в фоновом режиме, облегчая управление многозадачностью
`shutdown()` - применяется для остановки приема новых задач в пул потоков и запуска процедуры завершения работы пула потоков. Этот метод не останавливает выполнение уже запущенных задач, но после его вызова пул потоков не будет принимать новые задачи.
`awaitTermination()` - используется для ожидания завершения выполнения всех задач в пуле потоков после вызова `shutdown()`. Этот метод блокирует текущий поток до тех пор, пока все задачи не завершатся или не истечет заданный таймаут.

[java-level2-starter](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.5/src/com/dmdev/oop/lesson26/pool)
## 006 Потокобезопасные коллекции

Потокобезопасные коллекции в `java.util.concurrent` предоставляют механизмы для безопасного доступа к коллекциям в многопоточной среде.

Вот несколько классов из пакета `java.util.concurrent`, предоставляющих потокобезопасные коллекции:

1. **`ConcurrentHashMap` (Класс):**
    
    - `ConcurrentHashMap` является потокобезопасной реализацией интерфейса `Map`. Он обеспечивает высокую производительность в многопоточных приложениях.
    - Ключевые методы: `put()`, `get()`, `remove()`.
    - Основан на принципе разделения (шардирования) хранилища данных на небольшие сегменты, что позволяет потокам работать параллельно с разными частями карты, минимизируя блокировки.
2. **`CopyOnWriteArrayList` (Класс):**
    
    - `CopyOnWriteArrayList` предоставляет потокобезопасную реализацию интерфейса `List`. Это означает, что операции записи выполняются на копии списка, а не на самом списке.
    - Ключевые методы: `add()`, `remove()`, `get()`.
    - Подход копирования на запись обеспечивает безопасное чтение и запись в многопоточной среде, но может быть неэффективным для частых операций записи.
3. **`BlockingQueue` (Интерфейс) и его реализации:**
    
    - `BlockingQueue` представляет собой интерфейс для блокирующих очередей, которые широко используются в сценариях производителя-потребителя и в других многопоточных сценариях.
    - Реализации включают `LinkedBlockingQueue`, `ArrayBlockingQueue`, `PriorityBlockingQueue` и другие. Каждая из них имеет свои уникальные свойства и используется в разных сценариях.

![Pasted image 20240115100023.png|700](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/Pasted%20image%2020240115100023.png)
[java-level2-starter · GitHub](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.5/src/com/dmdev/oop/lesson25/queue)
## 007 CountDownLatch

Класс `CountDownLatch` в `java.util.concurrent` - это инструмент синхронизации, который позволяет одному или нескольким потокам ожидать завершения набора операций, выполняемых в других потоках.

`CountDownLatch` инициализируется с заданным счетчиком. Методы `await` блокируются до тех пор, пока текущий счетчик не достигнет нуля из-за вызовов метода `countDown()`, после чего все ожидающие потоки освобождаются, и любые последующие вызовы `await` немедленно возвращаются. Это явление происходит один раз - счетчик не может быть сброшен

**Класс CountDownLatch** является эффективным и простым в употреблении средством синхронизации, которое окажется полезным в тех случаях, когда поток исполнения должен находиться в состоянии ожидания до тех пор, пока не произойдет одно или несколько событий.

[java-level2-starter · GitHub](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.7/src/com/dmdev/oop/lesson26/latch)

## 008 CyclicBarrier

Средство синхронизации, позволяющее набору потоков ждать друг друга до достижения общей точки барьера. Циклические барьеры полезны в программах с фиксированным количеством потоков, которые должны периодически ждать друг друга. Барьер называется циклическим, потому что он может быть использован повторно после освобождения ожидающих потоков.

В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».
![89af0cb71aad4465bb9c934b8be91a67.gif](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/89af0cb71aad4465bb9c934b8be91a67.gif)
CyclicBarrier используется, когда несколько потоков выполняют разные подзадачи, и выходные данные этих подзадач необходимо объединить для формирования окончательного результата. После завершения выполнения потоки вызывают метод await() и ждут, пока другие потоки достигнут барьера. Как только все потоки достигнут, барьеры уступают место потокам.

[GitHub](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.8/src/com/dmdev/oop/lesson26/barrier)

## 009 Semaphore

Синхронизатор Semaphore реализует шаблон синхронизации [Семафор](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)). Чаще всего, семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (`Semaphore(int permits)` или `Semaphore(int permits, boolean fair)`) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.

Семафор контролирует доступ к общему ресурсу с помощью счетчика. Если счетчик больше нуля, доступ разрешен. Если оно равно нулю, то доступ запрещен. Счетчик учитывает разрешения, разрешающие доступ к общему ресурсу. Таким образом, для доступа к ресурсу потоку необходимо получить разрешение от семафора.
![9da48f85b5874362bc2279f181613c0e.gif](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/9da48f85b5874362bc2279f181613c0e.gif)
Доступ управляется с помощью счётчика: изначально значение счётчика равно `int permits`, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока.

Счетный семафор. Концептуально, семафор хранит набор разрешений. Каждая функция acquire() при необходимости блокируется, пока не появится разрешение, а затем берет его. Каждая функция release() добавляет разрешение, потенциально освобождая блокирующий приобретатель. Однако никакие реальные объекты разрешений не используются; семафор просто ведет подсчет количества доступных разрешений и действует соответствующим образом.

**Работа семафора**
 Обычно при использовании семафора поток, которому нужен доступ к общему ресурсу, пытается получить разрешение.
 - Если счетчик семафора больше нуля, поток получает разрешение, что приводит к уменьшению счетчика семафора.
 - В противном случае поток будет заблокирован до тех пор, пока не будет получено разрешение.
 - Когда потоку больше не нужен доступ к общему ресурсу, он освобождает разрешение, что приводит к увеличению счетчика семафора.
 - Если есть другой поток, ожидающий разрешения, то этот поток получит разрешение в это время.

[GitHub](https://github.com/dmdev2020/java-level2-starter/tree/lesson-26.9/src/com/dmdev/oop/lesson25/queue)