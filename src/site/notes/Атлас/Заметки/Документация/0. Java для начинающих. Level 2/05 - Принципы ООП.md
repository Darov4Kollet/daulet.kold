---
{"dg-publish":true,"permalink":"/atlas/zametki/dokumentacziya/0-java-dlya-nachinayushhih-level-2/05-princzipy-oop/","tags":["Java"],"noteIcon":"","created":"2023-12-12T23:21:14.882+05:00","updated":"2025-04-07T02:08:20.988+05:00"}
---


## 001 Инкапсуляция

Инкапсуляция скрытие данных и какую-то сложность привнесенную в ваш код от пользователя. Под пользователь имеется ввиду человек который работает с нашим классом. ТО ЕСТЬ по сути всё что мы отмечаем как private(приватный) это тоже можно считать инкапсуляцией. Мы скрываем наши поля от пользователей.

В Java инкапсуляция достигается путем объявления переменных экземпляра класса как закрытых, что означает, что к ним можно получить доступ только внутри класса. Чтобы разрешить внешний доступ к переменным экземпляра, определены публичные методы, называемые геттерами и сеттерами, которые используются для извлечения и изменения значений переменных экземпляра соответственно. Используя геттеры и сеттеры, класс может применять собственные правила проверки данных и гарантировать, что его внутреннее состояние остается непротиворечивым.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-11.1/src/com/dmdev/oop/lesson11)

## 002 Практическое задание/003 Домашнее задание

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-11-hw/src/com/dmdev/oop/lesson11/hw)

## 004 Наследование

Миссия наследование – мы хотим чтобы объект какого-то одного класса наследовал что-то от другого класса. Под что-то имеется ввиду поля и/или функционал который у него есть. Для того чтобы унаследовать класс в Java используется ключевое слово `extends`. И после появится кое-какая ошибка компиляции. Всё дело в том что при наследовании есть одно важное правило: Мы обязаны использовать какую-то из конструкторов который у нас есть в нашем базовом(родительский либо супер) классе. Мы создаем конструктор через ключевое слово `super` и вызываем конструктор нашего супер класса. Дело в том что через super мы теперь можем достучаться до всего что у нас доступно из нашего супер класса.

Java, Наследование является важным столпом ООП (объектно-ориентированного программирования). Это механизм в Java, с помощью которого одному классу разрешено наследовать функции (поля и методы) другого класса. В Java Наследование означает создание новых классов на основе существующих. Класс, который наследует от другого класса, может повторно использовать методы и поля этого класса. Кроме того, вы также можете добавлять новые поля и методы в свой текущий класс.

### ***Типы наследования Java***

Ниже приведены различные типы наследования, поддерживаемые Java.

1. Единичное наследование
2. Многоуровневое наследование
3. Иерархическое наследование
4. Множественное наследование
5. Гибридное наследование
#### ****1. Единоличное наследование****

При одиночном наследовании подкласс выводится только из одного суперкласса. Он наследует свойства и поведение класса с одним родителем. Иногда это также известно как простое наследование. На рисунке ниже «A» — родительский класс, а «B» — дочерний класс. Класс «B» наследует все свойства класса «A».

![Единичное наследование](https://media.geeksforgeeks.org/wp-content/uploads/20220728111827/1-660x329.jpg)
#### ****2. Многоуровневое наследование****

В многоуровневом наследовании производный класс будет наследовать базовый класс, и также как производный класс также будет выступать в качестве базового класса для других классов. На изображении ниже класс A служит базовым классом для производного класса B, который в свою очередь служит базовым классом для производного класса C. В Java класс не может напрямую обращаться к [членам прародителя](https://www.geeksforgeeks.org/g-fact-91) .

![Многоуровневое наследование](https://media.geeksforgeeks.org/wp-content/uploads/20220728111913/2-660x329.jpg)
#### ****3. Иерархическое наследование****

В иерархическом наследовании один класс служит суперклассом (базовым классом) для более чем одного подкласса. На изображении ниже класс A служит базовым классом для производных классов B, C и D.

![Иерархическое наследование в Java](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg)
#### 4. Множественное наследование ( ****через интерфейсы)****

В [Multiple heritage](https://www.geeksforgeeks.org/java-and-multiple-inheritance) один класс может иметь более одного суперкласса и наследовать функции от всех родительских классов. Обратите внимание, что Java не ****поддерживает**** множественное [наследование](https://www.geeksforgeeks.org/java-and-multiple-inheritance) с классами. В Java мы можем реализовать множественное наследование только через [Interfaces](https://www.geeksforgeeks.org/interfaces-in-java) . На изображении ниже класс C получен из интерфейсов A и B.

![Множественное наследование](https://media.geeksforgeeks.org/wp-content/uploads/20220728112121/3-660x329.jpg)
#### ****5. Гибридное наследование****

Это смесь двух или более из вышеперечисленных типов наследования. Поскольку Java не поддерживает множественное наследование с классами, гибридное наследование, включающее множественное наследование, также невозможно с классами. В Java мы можем достичь гибридного наследования только через [интерфейсы](https://www.geeksforgeeks.org/interfaces-in-java) , если мы хотим задействовать множественное наследование для реализации гибридного наследования.  
Однако важно отметить, что гибридное наследование не обязательно требует использования исключительно множественного наследования. Этого можно достичь посредством комбинации многоуровневого наследования и иерархического наследования с классами, иерархического и одиночного наследования с классами. Поэтому действительно возможно реализовать гибридное наследование, используя только классы, не полагаясь на тип множественного наследования. 

![Гибридное наследование](https://media.geeksforgeeks.org/wp-content/uploads/20220728112142/4-660x330.jpg)


[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-12.1/src/com/dmdev/oop/lesson11)

## 005 Класс Object

В Java все классы какие-бы мы не создавали, они по умолчанию наследуется от класса `Object`. Так как тут нет множественного наследования, то случается вот такая картина, то есть “ Laptop <- Computer <- Object”. Следовательно у нас все равно будет весь функционал что есть у класса Object. Потому-что у нас два уровня наследования. Методы, которые есть у всех объектов: Класс Object содержит базовую реализацию для нескольких методов, которые присутствуют у всех объектов в Java. Некоторые из этих методов включают: **`toString()`**: Этот метод возвращает строковое представление объекта. При необходимости вы можете переопределить его, чтобы вернуть более информативное описание объекта. `equals(Object obj)`: Этот метод используется для сравнения двух объектов на равенство. По умолчанию метод выполняет сравнение по ссылке на объект, но его можно переопределить для более точного сравнения по содержимому объектов. `hashCode()`: Этот метод возвращает целочисленное значение (хеш-код) объекта, которое обычно используется в структурах данных, таких как хеш-таблицы. `getClass()`: Этот метод возвращает объект типа Class, который представляет класс объекта. Это может быть полезно для рефлексии и других аналитических задач.

## 006 Инициализация объектов

Инициализация объектов в Java — это процесс присвоения начальных значений переменным объекта при его создании. Когда вы создаете новый объект с помощью оператора `new`, вы выделяете память для этого объекта в куче (`heap`) и вызываете конструктор класса для инициализации его полей. Вот несколько важных моментов, касающихся инициализации объектов в Java: Выделение памяти: При создании объекта оператором `new` выделяется память в куче для хранения его данных. В это время для всех его полей автоматически выделяется место в памяти, которое будет использоваться для хранения значений. Конструктор: Когда объект создается, вызывается конструктор класса. Конструктор — это специальный метод, имя которого совпадает с именем класса. Он выполняет начальную инициализацию объекта, устанавливая начальные значения для его полей. Если в классе не определен конструктор, Java предоставит конструктор по умолчанию (без параметров), который инициализирует поля объекта значениями по умолчанию для их типов (например, 0, null, false).

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-12.3/src/com/dmdev/oop/lesson11)

## 007 Абстрактные классы

Если мы хотим чтобы класс создался только для того чтобы его наследовали, то есть чтобы мы не могли создать экземпляры этого класса. Для того чтобы создать абстрактный класс нужно просто использовать ключевое слово `abstract`, этим мы запрещаем создавать объект этого класса.

Так вот, **абстрактный класс** — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.

💡 **Наш абстрактный класс — это просто «чертеж», по которому мы позже будем создавать классы-автомобили.**

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-12.4/src/com/dmdev/oop/lesson11)

## 008 Полиморфизм

Аннотация `@Override` – показывает то что этот метод переопределён. Полиморфизм – понятие: один интерфейс(открытый функционал который был унаследован) и множество реализаций. И можно использовать один и тот же тип ссылки на разные объекты, например `Computer laptop = new Laptop; Computer mobile = new Mobile;` Полиморфизм в Java — это способность объектов разных классов работать с одинаковым кодом. Это позволяет использовать общий интерфейс для работы с разными типами объектов, что делает код более гибким и удобным для использования.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-13.1/src/com/dmdev/oop/lesson11)
## 009 Приведение типов. Оператор instanceof

==instanceof== в Java - это оператор, который позволяет проверить, принадлежит ли объект определенному классу или является ли он его наследником. Он возвращает логическое значение true или false, в зависимости от того, соответствует ли объект указанному типу или нет. Простыми словами: instanceof говорит нам, является ли объект определенного класса или его подкласса.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-13.2/src/com/dmdev/oop/lesson11)
## 010 Интерфейсы

Интерфейсы мы используем тогда когда мы хотим привнести какой-то функционал в наш класс, потому что интерфейсы они по сути `public abstract`, то есть все их методы публичные и абстрактные, следовательно они служат только для того чтобы привнести какой-то новый функциональность в тот или иной класс. И у интерфейса нет никакой ограничений в том что один класс может реализовать много интерфейсов. Интерфейсы в Java представляют собой набор абстрактных методов (методов без тела) и константных переменных (переменных с постоянными значениями). Они позволяют определить контракт или соглашение о том, какие методы должны быть реализованы классами, которые реализуют (`implements`) эти интерфейсы. Простыми словами, интерфейсы — это как набор обязательных правил, которые класс должен следовать, чтобы считаться реализующим этот интерфейс.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-14.1/src/com/dmdev/oop/lesson11)
## 011 Интерфейсы. Нововведения

В Java 8 были введены новые возможности для интерфейсов: методы с реализацией по умолчанию (`default methods`) и закрытые методы (`private methods`). Default методы (методы с реализацией по умолчанию): Простыми словами, default методы позволяют добавлять реализацию метода в интерфейс, чтобы старые реализации интерфейсов могли обновляться без необходимости изменения всех классов, которые его реализуют. Private методы (закрытые методы): Private методы в интерфейсах п by weозволяют определять вспомогательные методы, которые используются только внутри интерфейса. Они служат для улучшения читаемости и уменьшения повторения кода, когда несколько default методов могут использовать общую реализацию.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-14.2/src/com/dmdev/oop/lesson11)
## 012 ООП. Практика

>Tasks.txt
>	1. Создать класс Hero, представляющий собой героя и содержащий поле `name`. Добавить конструктор, принимающий имя героя и геттер для имени (сеттер не нужен). Добавить метод `attackEnemy()`, выводящий в консоль сообщение о том, что герой атакует врага. Создать класс `TrainingGround`, содержащий метод `main`. Протестировать создание героя и его атаку.
>	2. Создать классы `Warrior`, `Mage` и `Archer`, представляющие собой наследников класса `Hero` переопределить в них метод `attackEnemy()` для вывода специализированного для этого класса сообщения об атаке. Протестировать создание героев различных классов и их атаки в классе `TrainingGround`.
>	3. Создать класс `Enemy`, представляющий собой врага и содержащий поле `health` (количество здоровья). Добавить конструктор, принимающий количество здоровья, а также сеттер и геттер. Добавить метод `takeDamage(int damage)`, который уменьшает количество здоровья в соответствии с полученным уроном. Переписать метод `attackEnemy` класса `Hero`, добавив ему параметр типа `Enemy`. Метод должен вызывать у врага метод `takeDamage` и передавать в него определённое количество урона. Переопределить метод в подклассах `Warrior`, `Mage` и `Archer` так, чтобы каждый герой наносил врагу разное количество урона.
>	4. Сделать класс `Hero` и его метод `attackEnemy` абстрактными.
>	5. Создать интерфейс `Mortal`, содержащий метод `isAlive()`. Сделать так, чтобы класс `Enemy` реализовывал интерфейс `Mortal`. Определить метод `isAlive` в классе `Enemy` так, чтобы тот возвращал true, если количество здоровья врага больше 0.
>	6. Создать класс `BattleGround` с методом `main`, в котором создать симуляцию героя, атакующего врага. 7*. Добавить герою показатель здоровья и возможность погибнуть. Добавить возможность врагу атаковать героя в ответ. Создать несколько видов врагов (наследников класса `Enemy`) с разными способностями (например, `Zombie` - имеет шанс воскреснуть при гибели) Дать героям уникальные способности. Продемонстрировать сражение героя с несколькими соперниками.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-15.1/src/com/dmdev/oop/lesson15)
## 013 Внутренние и вложенные классы

Если мы хотим использовать внутренний и внешний класс, то у вас должна быть невероятная зависимость между внутренним и внешним классом и возможно. Внутренние классы это те которые без модификатора static.

В Java, внутренние и вложенные классы представляют способы вложения одного класса в другой. Давайте разберем их подробно с простыми словами.

**Внутренние классы (Inner Classes):**

Внутренний класс - это класс, который определен внутри другого класса. Он имеет доступ ко всем членам внешнего класса, даже к частным. Внутренние классы могут быть полезными, когда вы хотите связать два класса очень тесно.

Пример внутреннего класса:

```java
javaCopy code
class Outer {
    private int outerValue;

    class Inner {
        void display() {
            System.out.println("Значение outerValue: " + outerValue);
        }
    }
}
```

Здесь **`Inner`** - это внутренний класс, и он имеет доступ к **`outerValue`**, который является переменной внешнего класса **`Outer`**.

**Вложенные классы (Nested Classes):**

Вложенный класс - это класс, который определен внутри другого класса, но он является статическим. Вложенные классы не имеют доступа к членам внешнего класса, если они не являются статическими.

Пример вложенного класса:

```java
javaCopy code
class Outer {
    private static int outerValue;

    static class Nested {
        void display() {
            System.out.println("Значение outerValue: " + outerValue);
        }
    }
}
```

Здесь **`Nested`** - это вложенный класс, и он может получить доступ только к статической переменной **`outerValue`** внешнего класса **`Outer`**.

**Различия между внутренними и вложенными классами:**

1. Внутренние классы имеют доступ ко всем членам внешнего класса, включая приватные. Вложенные классы могут обращаться только к статическим членам внешнего класса.
2. Для создания экземпляра внутреннего класса, вы должны сначала создать экземпляр внешнего класса. Для вложенных классов это не требуется.
3. Внутренние классы используются, когда вам нужен доступ к данным и методам внешнего класса, а вложенные классы используются, когда вам не нужен такой доступ и вы хотите организовать классы логически.
4. Вложенные классы чаще используются как вспомогательные классы, например, для разделения функциональности внутри одного класса.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-16.1/src/com/dmdev/oop/lesson15)

## 014 Перечисляемые типы. Enum

Одна из главных преимуществ использования `enum` заключается в том, что это обеспечивает безопасность типов данных. Нам не нужно беспокоиться о том, что кто-то случайно присвоит неправильное значение переменной типа enum. Компилятор Java проверяет, что значения переменных enum соответствуют определенным константам в enum, и предотвращает присвоение некорректных значений. Представьте, что у вас есть специальный список значений, которые не могут меняться. Например, дни недели: понедельник, вторник, среда и так далее. Вы хотите убедиться, что переменная может принимать только одно из этих значений, и ничего кроме них. Используя `enum`, вы можете создать такой список, и Java будет знать, что этот список может содержать только определенные значения. Вы можете выбирать значения из списка, присваивать их переменным и проверять, какое значение сейчас хранится в переменной. Вот пример:

В этом примере enum `DayOfWeek` содержит дни недели. Мы можем создавать переменные типа `DayOfWeek` и присваивать им только значения из списка. Например, `today` может быть только одним из дней недели. Это упрощает работу с ограниченным набором значений и предотвращает ошибки, связанные с неправильными значениями переменных.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-17.1/src/com/dmdev/oop/lesson16)
## 015 Практическое задание/016 Домашнее задание

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-15-hw/src/com/dmdev/oop/lesson15/hw)