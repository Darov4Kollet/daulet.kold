---
{"dg-publish":true,"permalink":"/atlas/zametki/dokumentacziya/0-java-dlya-nachinayushhih-level-2/04-stroki/","tags":["Java"],"noteIcon":"","created":"2023-12-12T23:19:52.865+05:00","updated":"2025-04-07T02:08:15.563+05:00"}
---

## 001 Класс String. Теория

Класс `String` в Java — это `final` класс, который не может иметь потомков. Класс String — `immutable` класс, то есть его объекты не могут быть изменены после создания. Любые операции над объектом String, результатом которых должен быть объект класса String, приведут к созданию нового объекта.

Самое главное поле в классе `String` это __byte[] value__, представляющий из себя массив byte[], то есть по сути это есть наша строчка. В предыдущих версиях (ранее 1.8) Java это был массив символов а не байтов, это сделано в целях производительности и расходов памяти.

==@Deprecated== - аннотация, чтобы пометить нежелательные в использовании методы 

> [!info] Функционалы класса String
> Метод _charAt(int): char_ - принимает __int__ это индекс нашего элемента и возвращает нам char, то есть символ по этому индексу. `char charAt(int index)` возвращает значение char по указанному индексу. Индекс колеблется от 0 до `length()-1`.
> Метод _compareTo(String): int_ - он очень похож на equals() но возвращает __int__, то есть сравнивает строки с друг другом. Он выполняет последовательное сравнение букв в строке, имеющих одинаковую позицию.
> Метод _concat(String): String_ - очень похож на конкатинацию строк, объединяет строки, путем добавления одной строки в конец к другой.
> ![Pasted image 20240129161533.png|420](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/Pasted%20image%2020240129161533.png)
> Метод _contains(CharSequence): boolean_ -  используется для проверки того, является ли определенный набор символов частью данной строки или нет. Метод contains() в Java возвращает true, только если это __string__ содержит «_s_», иначе — false.
> Метод _endsWith(String): boolean_ - проверяет, заканчивается ли эта строка указанным окончанием. endsWith() возвращает значение true, если последовательность символов, представленного аргумента является окончанием последовательности символов, представленного этим объектом; в противном случаи значение false.
> Методы _equals(Object): boolean_ - Этот метод сравнивает содержимое объектов и выводит значение типа `boolean`. Значение `true` - если содержимое эквивалентно, и `false` — если нет. Операция == не рекомендуется для сравнения объектов в Java. Дело в том, что при сравнении объектов, операция == вернет true лишь в одном случае — когда ссылки указывают на один и тот же объект. В данном случае не учитывается содержимое переменных класса.
> Метод _format(String, Object): String_ - В метод String.format первым параметром передается строка-шаблон, в которой, на местах, в которые мы хотим подставить значения, стоят специальные символы: %s, %d.  После строки-шаблона передаются параметры, значения которых и будут подставлены на место символов %s, %d. Если нужно подставить строку мы пишем %s, если число — %d.
> ![Pasted image 20240129170259.png](/img/user/%D0%90%D1%82%D0%BB%D0%B0%D1%81/%D0%A3%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%8B/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B/Pasted%20image%2020240129170259.png)
> Методы _getBytes(String): byte[]_ и _indexOf(...)_ - ==getBytes(String charsetName)== – кодирует данную строку в последовательность байтов, используя charsetName (кодировку), сохраняет результат в новый массив байтов.
> ==int indexOf(int ch)== - возвращает индекс в данной строке первого вхождения указанного символа, Если же символ который мы ищем, отсутствует в данной строке, мы получим -1.
> Методы _isBlank(): boolean_ и _isEmpty(): boolean_ - `isEmpty` - проверяет, является ли строка пустой ("") или значение `null`. `isBlank` - проверяет, есть-ли в строке пробел, пустая строка ("") или значение `null`.
> Методы _lastIndexOf(): int_ и _length(): int_ - 
> **public int lastIndexOf(int ch)** - поиск одного единственного символа
> **public int lastIndexOf(int ch, int fromIndex)** - поиск одного единственного символа начиная с символа номер fromIndex. Счёт происходит в обратном порядке.
> **public int lastIndexOf(String str, int fromIndex)** - аналогично предыдущему. Но происходит поиск не одного символа, а целой строки.
> **Метод length()** – возвращает длину строки в Java. Длина равна числу 16-разрядных символов Юникода в строке.
> Метод _lines()_ - преобразует все строчки строки в соответствующий Stream.
> Методы _matches(String): boolean_ и _replace(): String_ - 
> Метод **matches(String)** класса String проверяет, соответствует ли строка заданному регулярному выражению. Метод возвращает значение true, если строка соответствует регулярному выражению, и false в противном случае.
> Метод **replace(String, String)** класса String заменяет все вхождения подстроки, указанной в первом аргументе, на подстроку, указанную во втором аргументе. Метод возвращает новую строку, в которой были произведены замены.
> Метод _split(): String[]_ и _startsWith(): boolean_ - 
> **Метод split()** – в Java разделяет данную строку вокруг данного регулярного выражения и имеет два варианта. - В Java split() возвращает массив строк, вычисленных путем разделения данной строки вокруг данного регулярного выражения.
> **Метод startsWith()** в Java имеет два варианта и проверяет начинается ли строка с указанного префикса, начиная с указанного индекса или с начала (по умолчанию). В Java startsWith() возвращает значение true, если последовательность символов, представленного аргумента является префиксом последовательности символов, представляемой данной строкой; в противном случае значение false.
> Методы _substring(): String_ и _toCharArray(): char[]_ - 
> **Метод substring()** в Java имеет два варианта и возвращает новую строку, которая является подстрокой данной строки. Подстрока начинается с символа, заданного индексом, и продолжается до конца данной строки или до endIndex-1, если введен второй аргумент.
> **Метод toCharArray()** обеспечивает простой способ преобразования строки в массив символов всего одним вызовом метода.
> Методы _toLowerCase(): String_ и _toUpperCase(): String_ - 
> В Java **toLowerCase()** возвращает строку, преобразованную в нижний регистр.
> Метод **toUpperCase()** возвращает значение строки, на которой он был вызван, преобразованное в верхний регистр.
> Метод _trim(): String_ и _valueOf(): String_ - 
> В Java **trim()** возвращает копию данной строки, в которой удаляются начальные и конечные пробелы, или данную строку, если она не имеет начальных или конечных пробелов.
> **Метод valueOf()** в Java имеет следующие варианты, которые зависят от передаваемых параметров. Этот метод возвращает строковое представление переданного аргумента.
 
## 002 Класс String. Практика

Мы выполним эти задачи:

1. Заменить все грустные смайлы :( в строке на весёлые :)
2. Написать функцию, принимающую 2 параметра: строку и слово - и возвращающую true, если строка начинается и заканчивается этим словом.
3. Написать функцию, принимающую в качестве параметров имя, фамилию и отчество и возвращающую инициалы в формате "Ф.И.О". Учесть, что входные параметры могут быть в любом регистре, а результирующая строка должна быть в верхнем.
4. Подсчитать количество всех точек, запятых и восклицательных знаков в строке.
5. Написать функцию, разбивающую строку на равные части по n символов и сохраняющую отдельные части в массив. Вывести этот массив.

[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-10.2/src/com/dmdev/oop/lesson10)


	Task1. Заменить все грустные смайлы :( в строке на весёлые :)

Мы создали новый проект и новый пакет и в нём класс Task1 для первой задачи. Создали функцию main, переменную value типа String, где будет какие-то слова и часть грустных и весёлых смайликов. Потом написали статическую функцию потому что наша функция main статическая и статическая функция может вызывать только другую статическую функцию, далее она будет возвращать строку и назовем его replace() и как параметры она будет принимать наше входное значение replace(String value). В функции main мы вызываем его присваивая к переменной result.

	💡 Ctrl + Alt + V – создание переменной

Потом выводим на экран переменную result. Для того чтобы заменить какой-то символ или значение мы вызываем ==value.replace()==, и в target: пишем то что нужно заменить, replacement: то на что мы будем заменять. Все это присваиваем к переменной result. И возвращаем его с помощью return.

>Task2. 
>Написать функцию, принимающую 2 параметра: строку и слово - и возвращающую true, если строка начинается и заканчивается этим словом.

Создали класс Task2 и функцию main, создаем статическую функцию типа boolean и назовем его isStartAndEnd() который в качестве параметров принимает String target, String word, потом у target вызываем startsWith(word) && target.endWith(word) и возвращаем с помощью return.

В функции main создаем строку value передаем туда “123 asdasd dada 123”, потом строку word в котором передаем слово “123” и выводим на экран функцию isStartAndEnd(value, word)

>Task3. 
>Написать функцию, принимающую в качестве параметров имя, фамилию и отчество и возвращающую инициалы в формате "Ф.И.О". Учесть, что входные параметры могут быть в любом регистре, а результирующая строка должна быть в верхнем.

Создаем новый класс Task3 и функцию main, создаем статический метод format типа String и в качестве параметров объявляем строки firstName, lastName, patronymicName. И с помощью метода charAt(0) мы берем первую букву наших символов. И возвращаем их в формате “Ф.И.О”.

С помощью _Character.toUpperCase_ мы можем привести в большой регистр только один символ который задали в charAt().

>Task4. 
>Подсчитать количество всех точек, запятых и восклицательных знаков в строке.

Создаем новый класс Task4 и функцию main, создаем строку value в котором будет точки, запятые и восклицательные знаки которых мы будем искать. Потом создаем статическую функцию countSymbols типа int который возвращает нам количество таких вот выражений, и в качестве параметра передаем туда нашу строку value.

С помощью метода ==replace(target: “.”, replacement: “”)== мы заменяем точку на пустую строку, так делаем для запятых и для восклицательных знаков. Присваиваем все это к перемену result типа String. Потом возвращаем длину нашей строки минус(-) длина строки result. ВСЁ, теперь выводим на экран функцию countSymbols(value).

>Task5. 
>Написать функцию, разбивающую строку на равные части по n символов и сохраняющую отдельные части в массив. Вывести этот массив.

## 003 Класс StringBuilder and StringBuffer



[github.com](https://github.com/dmdev2020/java-level2-starter/tree/lesson-10.3/src/com/dmdev/oop/lesson10)

**String vs StringBuffer vs StringBuilder**

|                    | String                                                       | StringBuffer                                                                       | StringBuilder                                                                      |
| ------------------ | ------------------------------------------------------------ | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| Изменяемость       | `Immutable` (нет)                                            | `mutable` (да)                                                                     | `mutable` (да)                                                                     |
| Расширяемость      | `final` (нет)                                                | `final` (нет)                                                                      | `final` (нет)                                                                      |
| Потокобезопасность | Да, за счет неизменяемости                                   | Да, за счет синхронизации                                                          | Нет                                                                                |
| Когда использовать | При работе со строками, которые редко будут модифицироваться | При работе со строками, которые часто будут модифицироваться в многопоточной среде | При работе со строками, которые часто будут модифицироваться, в однопоточной среде |

Чтобы справиться с созданием временного мусора из-за модификаций объекта String, можно использовать класс `StringBuffer`.

Объект класса `StringBuffer` может содержать в себе определенный набор символов, длину и значение которого можно изменить через вызов определенных методов.

`StringBuilder` в Java — класс, представляющий последовательность символов. Он очень похож на `StringBuffer` во всем, кроме потокабезопасности.

## 004 Практическое задание

>Task.txt 
>Проверить, является ли введённая строка палиндромом, т.е. читается одинаково в обоих направлениях

[github.com](https://github.com/dmdev2020/java-level2-starter/blob/lesson-10-hw/src/com/dmdev/oop/lesson10/hw/Task1.java)

## 005 Домашнее задание

>Task.txt
>Написать программу, преобразующую строку, содержащую число в римском формате, в число в арабском формате. Границы чисел: от 1 до 3999. Предусмотреть случай, когда меньший символ идёт перед большим: Например CM == 900. Соответствие: M 1000 D 500 C 100 L 50 X 10 V 5 I 1

[github.com](https://github.com/dmdev2020/java-level2-starter/blob/lesson-10-hw/src/com/dmdev/oop/lesson10/hw/Task2.java)